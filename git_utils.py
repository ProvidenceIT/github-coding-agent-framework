"""
Git Utilities for Autonomous Agents
====================================

Automatic git operations for agent sessions including:
- Intelligent commit message generation
- Automatic commit on session completion
- Push to remote repository
- Branch management

Features:
- Generates descriptive commit messages from session data
- Handles Linear issue tracking in commits
- Automatic push with error handling
- Configurable auto-commit behavior
"""

import subprocess
from pathlib import Path
from typing import Dict, List, Optional, Tuple
from datetime import datetime


class GitManager:
    """
    Manages git operations for autonomous agents.

    Features:
    - Smart commit message generation
    - Automatic commits on session completion
    - Push to remote with error handling
    - Linear issue tracking in commits
    """

    def __init__(self, project_dir: Path, auto_push: bool = True):
        self.project_dir = project_dir
        self.auto_push = auto_push

    def check_git_configured(self) -> bool:
        """Check if git is properly configured."""
        try:
            # Check if git user is configured
            result = subprocess.run(
                ['git', 'config', 'user.name'],
                cwd=self.project_dir,
                capture_output=True,
                text=True
            )

            if result.returncode != 0 or not result.stdout.strip():
                return False

            result = subprocess.run(
                ['git', 'config', 'user.email'],
                cwd=self.project_dir,
                capture_output=True,
                text=True
            )

            return result.returncode == 0 and result.stdout.strip()

        except Exception:
            return False

    def configure_git(self, name: str = "Autonomous Agent", email: str = "agent@providence.it"):
        """Configure git if not already configured."""
        try:
            subprocess.run(
                ['git', 'config', 'user.name', name],
                cwd=self.project_dir,
                check=True
            )

            subprocess.run(
                ['git', 'config', 'user.email', email],
                cwd=self.project_dir,
                check=True
            )

            return True
        except Exception as e:
            print(f"‚ö†Ô∏è  Failed to configure git: {e}")
            return False

    def has_changes(self) -> bool:
        """Check if there are uncommitted changes."""
        try:
            result = subprocess.run(
                ['git', 'status', '--porcelain'],
                cwd=self.project_dir,
                capture_output=True,
                text=True,
                check=True
            )

            return bool(result.stdout.strip())
        except Exception:
            return False

    def get_changed_files(self) -> List[str]:
        """Get list of changed files."""
        try:
            result = subprocess.run(
                ['git', 'status', '--porcelain'],
                cwd=self.project_dir,
                capture_output=True,
                text=True,
                check=True
            )

            files = []
            for line in result.stdout.strip().split('\n'):
                if line:
                    # Format: "XY filename" where XY is status code
                    files.append(line[3:])

            return files
        except Exception:
            return []

    def generate_commit_message(
        self,
        issues_completed: List[str],
        issues_attempted: List[str],
        session_metrics: Dict,
        session_id: str
    ) -> str:
        """
        Generate intelligent commit message from session data.

        Format:
        feat: Implement [features from issues]

        Session: [session_id]
        Issues completed: [list]
        Duration: [time]

        - [file changes summary]

        ü§ñ Generated by autonomous coding agent
        Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>
        """
        # Determine commit type
        if len(issues_completed) == 0:
            commit_type = "chore"
            summary = "Work in progress - session incomplete"
        elif len(issues_completed) == 1:
            commit_type = "feat"
            summary = f"Implement {issues_completed[0]}"
        else:
            commit_type = "feat"
            summary = f"Implement {len(issues_completed)} features"

        # Build commit message
        message_parts = [
            f"{commit_type}: {summary}",
            "",
            f"Session: {session_id}",
        ]

        # Add completed issues
        if issues_completed:
            message_parts.append("")
            message_parts.append("Completed:")
            for issue in issues_completed:
                message_parts.append(f"  - {issue}")

        # Add session metrics
        if session_metrics:
            message_parts.append("")
            message_parts.append("Session Metrics:")

            duration = session_metrics.get('duration_minutes', 'N/A')
            message_parts.append(f"  - Duration: {duration} minutes")

            api_calls = session_metrics.get('linear_api_calls', 0)
            cached = session_metrics.get('linear_api_cached', 0)
            message_parts.append(f"  - Linear API: {api_calls} calls ({cached} cached)")

            tools = len(session_metrics.get('tools_used', {}))
            message_parts.append(f"  - Tools used: {tools}")

            errors = session_metrics.get('errors', 0)
            if errors > 0:
                message_parts.append(f"  - Errors: {errors}")

        # Add changed files summary
        changed_files = self.get_changed_files()
        if changed_files and len(changed_files) <= 10:
            message_parts.append("")
            message_parts.append("Files changed:")
            for file in changed_files[:10]:
                message_parts.append(f"  - {file}")
        elif changed_files:
            message_parts.append("")
            message_parts.append(f"Files changed: {len(changed_files)} files")

        # Add footer
        message_parts.extend([
            "",
            "ü§ñ Generated by autonomous coding agent",
            "",
            "Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
        ])

        return '\n'.join(message_parts)

    def commit(
        self,
        issues_completed: List[str],
        issues_attempted: List[str],
        session_metrics: Dict,
        session_id: str
    ) -> Tuple[bool, str]:
        """
        Commit changes with generated message.

        Returns:
            (success: bool, message: str)
        """
        # Check if git is configured
        if not self.check_git_configured():
            print("üìù Configuring git for first time...")
            if not self.configure_git():
                return False, "Failed to configure git"

        # Check for changes
        if not self.has_changes():
            return True, "No changes to commit"

        try:
            # Stage all changes
            subprocess.run(
                ['git', 'add', '-A'],
                cwd=self.project_dir,
                check=True
            )

            # Generate commit message
            commit_msg = self.generate_commit_message(
                issues_completed,
                issues_attempted,
                session_metrics,
                session_id
            )

            # Commit
            subprocess.run(
                ['git', 'commit', '-m', commit_msg],
                cwd=self.project_dir,
                check=True,
                capture_output=True
            )

            print(f"‚úÖ Committed changes for session {session_id}")
            return True, f"Committed {len(self.get_changed_files())} files"

        except subprocess.CalledProcessError as e:
            error_msg = f"Failed to commit: {e.stderr.decode() if e.stderr else str(e)}"
            print(f"‚ùå {error_msg}")
            return False, error_msg

    def push(self, branch: str = "main") -> Tuple[bool, str]:
        """
        Push commits to remote repository.

        Returns:
            (success: bool, message: str)
        """
        if not self.auto_push:
            return True, "Auto-push disabled"

        try:
            # Check if remote exists
            result = subprocess.run(
                ['git', 'remote'],
                cwd=self.project_dir,
                capture_output=True,
                text=True,
                check=True
            )

            if not result.stdout.strip():
                return False, "No git remote configured"

            # Push to remote
            print(f"üì§ Pushing to remote ({branch})...")
            subprocess.run(
                ['git', 'push', 'origin', branch],
                cwd=self.project_dir,
                check=True,
                capture_output=True
            )

            print(f"‚úÖ Successfully pushed to origin/{branch}")
            return True, f"Pushed to origin/{branch}"

        except subprocess.CalledProcessError as e:
            error_msg = e.stderr.decode() if e.stderr else str(e)

            # Handle common errors
            if "authentication" in error_msg.lower() or "permission" in error_msg.lower():
                print(f"‚ö†Ô∏è  Push failed: Authentication required")
                print(f"   Run: gh auth login")
                print(f"   Or set up SSH keys")
                return False, "Authentication required"

            elif "rejected" in error_msg.lower():
                print(f"‚ö†Ô∏è  Push rejected: Pull required first")
                return False, "Pull required before push"

            else:
                print(f"‚ùå Push failed: {error_msg}")
                return False, error_msg

    def commit_and_push(
        self,
        issues_completed: List[str],
        issues_attempted: List[str],
        session_metrics: Dict,
        session_id: str,
        branch: str = "main"
    ) -> Tuple[bool, str]:
        """
        Commit changes and push to remote in one operation.

        Returns:
            (success: bool, message: str)
        """
        # Commit
        commit_success, commit_msg = self.commit(
            issues_completed,
            issues_attempted,
            session_metrics,
            session_id
        )

        if not commit_success:
            return False, commit_msg

        if commit_msg == "No changes to commit":
            return True, commit_msg

        # Push
        push_success, push_msg = self.push(branch)

        if not push_success:
            return False, f"Committed but push failed: {push_msg}"

        return True, f"{commit_msg}, {push_msg}"


def create_git_manager(project_dir: Path, auto_push: bool = True) -> GitManager:
    """
    Factory function to create GitManager instance.

    Usage:
        git_mgr = create_git_manager(project_dir, auto_push=True)

        # At end of session
        success, msg = git_mgr.commit_and_push(
            issues_completed=['PRO-56: Auth flow'],
            issues_attempted=['PRO-56'],
            session_metrics=logger.metrics,
            session_id='session_001'
        )

        if success:
            print(f"‚úÖ {msg}")
        else:
            print(f"‚ö†Ô∏è  {msg}")
    """
    return GitManager(project_dir, auto_push)
